# TypeScript
TypeScript Kodları
Soru1.ts
function mergeArrays<T, U>(arr1: T[], arr2: U[]): (T | U)[] {
return [...arr1, ...arr2];}
const numArr = [1, 2, 3];
const strArr = ["a", "b", "c"];
console.log(mergeArrays(numArr, strArr));

Soru2.ts
class Car {
drive() {
console.log("Araç sürülüyor...");
}
}
class Truck {
drive() {
console.log("Kamyon sürülüyor...");
}
loadCargo() {
console.log("Kargo yükleniyor...");
}
}
type Vehicle = Car | Truck;
function useVehicle(vehicle: Vehicle) {
vehicle.drive();
if ("loadCargo" in vehicle) {
vehicle.loadCargo();
}
}
const car = new Car();
const truck = new Truck();
useVehicle(car);
useVehicle(truck);

Soru3.ts
class Logger {
private logHistory: string[] = [];
log(message: string) {
console.log(message);
this.logHistory.push(message);
}
getHistory(): string[] {
return this.logHistory;
}
}
const logger = new Logger();
logger.log("İlk log.");
logger.log("İkinci log.");
console.log(logger.getHistory());

Soru4.ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
return obj[key];
}
const user = { name: "Havva", age: 21 };
console.log(getProperty(user, "name"));
console.log(getProperty(user, "age"));

Soru5.ts
type User = { id: number; name: string; email: string };
const users: User[] = [
{ id: 1, name: "Ali", email: "ali@mail.com" },
{ id: 2, name: "Ayşe", email: "ayse@mail.com" },
];
function search(id: number): User | undefined;
function search(name: string): User[];
function search(param: number | string): User | User[] | undefined {
if (typeof param === "number") {
return users.find(user => user.id === param);
} else {
return users.filter(user => user.name === param);
}
}
console.log(search(1));
console.log(search("Hazal"));

Soru6.ts
class MemoryCache<K, V> {
private data = new Map<K, V>();
set(key: K, value: V): void {
this.data.set(key, value);
}

get(key: K): V | undefined {
return this.data.get(key);
}

clear(): void {
this.data.clear();
}
}

const cache = new MemoryCache<string, number>();
cache.set("user:1_score", 100);

console.log(cache.get("user:1_score"));
cache.clear();
console.log(cache.get("user:1_score"));

Soru7.ts
type User = { id: number; name: string; email: string };

const users: User[] = [
{ id: 1, name: "  Havva", email: "Havva@mail.com" },
{ id: 2, name: "Hazal", email: "Hazal@mail.com" },
];
function updateUser(
id: number,
updates: Partial
): Readonly | undefined {
const user = users.find((u) => u.id === id);
if (!user) {
return undefined;
}
Object.assign(user, updates);

return user;
}
console.log("Eski: ", users[0]);
const updatedUser = updateUser(1, { email: "Havva.yeni@mail.com" });
console.log("Yeni: ", updatedUser);

Soru8.ts
function sum(...numbers: number[]): number {
return numbers.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3));
console.log(sum(10, 20, 30, 40));

Soru9.ts
abstract class Shape {

abstract getArea(): number;
}

class Circle extends Shape {
private radius: number;

constructor(radius: number) {
super();
this.radius = radius;
}
getArea(): number {
return Math.PI * this.radius ** 2;
}
}
const circle = new Circle(10);
console.log(circle.getArea());

Soru10.ts
class MathHelper {
static PI: number = 3.14159;
static calculateCircumference(radius: number): number {
return 2 * MathHelper.PI * radius;
}
}
console.log(MathHelper.PI);
console.log(MathHelper.calculateCircumference(10));

Soru11.ts
type UnwrapPromise = T extends Promise ? U : T;

type pNum = Promise;
type regularNum = number;

let val1: UnwrapPromise = 10;
let val2: UnwrapPromise = 20;
let val3: UnwrapPromise = "string";

console.log("Soru 11 Başarılı!", val1, val2);

Soru12.ts
type GetReturnType = T extends (...args: any[]) => infer R ? R : never;
const fn1 = () => "hello";
const fn2 = (a: number) => a * 2;

let ret1: GetReturnType = "world";
let ret2: GetReturnType = 100;
let error1: GetReturnType = 123;
console.log("Soru 12 Başarılı!", ret1, ret2);

Soru13.ts

Soru14.ts
type DeepReadonly = {
readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

type Config = { api: { url: string; }, features: string[] };
const config: DeepReadonly = {
api: { url: "http://..." },
features: ["A", "B"]
};
config.api.url = "yeni-url";
config.features.push("C");
console.log("Soru 14 Başarılı!", config.api.url);

Soru15.ts
// SADECE BU SATIRI DEĞİŞTİRİN
type PickByValueType<T, V> = {
[K in keyof T as T[K] extends V ? K : never]: T[K];
};

// ---- KOD BLOKU (DOKUNMAYIN) ----
type Sample = { name: string; age: number; active: boolean; };
type StringOrNumberProps = PickByValueType<Sample, string | number>;

// Bu değişken, tip tanımına uyar ve hata vermez.
const valid: StringOrNumberProps = {
name: "Ali",
age: 30
};
console.log("Soru 15 Başarılı!", valid.name);

soru16.ts
type Brand<K, T> = K & { __brand: T };
type UserID = Brand<string, "UserID">;
type PostID = Brand<string, "PostID">;
function logID(id: string) { console.log(id); }
let userID = "user-123" as UserID;
let postID = "post-456" as PostID;
logID(userID);
logID(postID);
userID = postID;
console.log("Soru 16 Başarılı!");

Soru17.ts
type FilterUnion<T, U> = T extends U ? never : T;
type AllStatus = 'pending' | 'active' | 'inactive' | 'deleted';
type ActiveStatus = 'active' | 'pending';
type InactiveStatus = FilterUnion<AllStatus, ActiveStatus>;
let status1: InactiveStatus = 'inactive';
let status2: InactiveStatus = 'deleted';
let errorStatus: InactiveStatus = 'pending';
console.log("Soru 17 Başarılı!", status1, status2);

Soru18.ts
type LastParameter = T extends (...args: [...infer P, infer L]) => any ? L : never;
const fn1 = (a: string, b: number, c: boolean) => {};
const fn2 = (a: Date) => {};
let p1: LastParameter = true;
let p2: LastParameter = new Date();
let errorP: LastParameter = "string";
console.log("Soru 18 Başarılı!", p1);

Soru19.ts
type Flatten = T extends (infer U)[] ? U : T;
type NumArray = number[];
type Str = string;
let el1: Flatten = 123;
let el2: Flatten = "hello";
let errorEl: Flatten = "string";
console.log("Soru 19 Başarılı!");

Soru20.ts
// SADECE BU SATIRI DEĞİŞTİRİN (Rekürsif ve Template Literal tabanlı çözüm)
type ParseRouteParams =
T extends ${string}/:${infer Param}/${infer Rest}
? { [K in Param | keyof ParseRouteParams</${Rest}>]: string }
: T extends ${string}/:${infer Param}
? { [K in Param]: string }
: {};
type Route1 = "/users/:id";
type Route2 = "/posts/:postId/comments/:commentId";
type Params1 = ParseRouteParams;
type Params2 = ParseRouteParams;
const p1: Params1 = { id: "123" };
const p2: Params2 = { postId: "abc", commentId: "xyz" };
const errorP1: Params1 = { userId: "123" };
const errorP2: Params2 = { postId: "abc" };
console.log("Soru 20 Başarılı!");
